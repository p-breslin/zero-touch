import os
import logging
from typing import Any, Iterator
from dotenv import load_dotenv

from agno.workflow import Workflow
from agno.agent import RunResponse

from agno.knowledge.agent import AgentKnowledge
from agno.embedder.openai import OpenAIEmbedder
from agno.vectordb.chroma.chromadb import ChromaDb

from src.paths import DATA_DIR
from agents.agent_builder import build_agent
from utils.logging_setup import setup_logging
from services.create_engine import create_db_engine
from utils.helpers import validate_response, load_yaml
from models import SQLPlan, SchemaInfo


load_dotenv()
setup_logging()
log = logging.getLogger(__name__)


class Pipeline(Workflow):
    """
    An Orchestrator Workflow to manage the inference process.
    """

    knowledge_base: AgentKnowledge
    db_engine: Any

    def __init__(self, **workflow_kwargs: Any):
        super().__init__(**workflow_kwargs)

        # Set up ChromaDB source for the Knowledge Base
        db_path = str(DATA_DIR / "ChromaDB")
        embedding_model = os.getenv("EMBEDDING_MODEL")
        embedder = OpenAIEmbedder(id=embedding_model, dimensions=3072)

        chromadb_collection_name = os.getenv("CHROMADB_COLLECTION")
        chromadb_instance = ChromaDb(
            collection=chromadb_collection_name,
            path=db_path,
            persistent_client=True,
            embedder=embedder,
        )
        self.knowledge_base = AgentKnowledge(
            vector_db=chromadb_instance, num_documents=10
        )

        # Set up the SQL database engine
        self.db_engine = create_db_engine()
        log.info(
            f"Workflow '{self.name or 'Pipeline'}' initialized with session_id: {self.session_id}"
        )

    def create_agent(self, key, knowledge=False):
        kb = self.knowledge_base if knowledge else None
        agent = build_agent(
            agent_key=key,
            db_engine=self.db_engine,
            knowledge_base=kb,
        )
        log.info(f"Agent '{agent.name}' built.")
        return agent

    def process_response(self, response, model, agent_name):
        try:
            structured_content = validate_response(
                response.content, model, savefile=agent_name
            )
            log.info(f"{agent_name} response validated.")
            return structured_content
        except Exception as e:
            log.exception(f"Validation error: {response.content}: {e}")
            return None

    def run(self) -> Iterator[RunResponse] | None:
        log.info(
            f"Workflow '{self.name}' run method started. Session ID: {self.session_id}, Run ID: {self.run_id}"
        )

        # Load queries
        queries = load_yaml("queries")

        # --- 1. Knowledge Base Agent ---
        log.info("Invoking KnowledgeBase_Agent...")
        kb_agent = self.create_agent("KnowledgeBase_Agent", knowledge=True)
        kb_query = queries.get("knowledgebase_query")

        kb_response: RunResponse = kb_agent.run(kb_query)
        schema_info: SchemaInfo | None = self.process_response(
            kb_response, SchemaInfo, kb_agent.name
        )
        if not schema_info:
            log.error("KnowledgeBase_Agent failed. Halting.")
            return RunResponse(
                content="Error: KnowledgeBase_Agent failed.", run_id=self.run_id
            )
        log.info("Schema information retrieved successfully.")
        self.session_state["knowledgebase_info"] = schema_info.model_dump()

        # --- 2. Planner Agent ---
        log.info("Invoking Planner_Agent...")
        planner_agent = self.create_agent("Planner_Agent")
        planner_query_template = queries.get("planner_query")

        # Prepare input
        planner_query = planner_query_template.format(
            schema_info=schema_info.model_dump_json(indent=2)
        )
        planner_response: RunResponse = planner_agent.run(planner_query)
        sql_plan: SQLPlan | None = self.process_response(
            planner_response, SQLPlan, planner_agent.name
        )

        if not sql_plan:
            log.error("Planner_Agent failed to produce a valid SQLPlan.")
            return RunResponse(
                content="Error: Planner_Agent failed.",
                run_id=self.run_id,
                session_id=self.session_id,
            )

        # Store the generated plan in session_state
        self.session_state["sql_plan"] = sql_plan.model_dump()
        log.info(
            f"SQLPlan generated by {planner_agent.name} and stored in session_state."
        )
        log.debug(f"Generated SQLPlan: \n{sql_plan.model_dump_json(indent=2)}")

        return RunResponse(
            run_id=self.run_id,
            session_id=self.session_id,
            content=f"Phase 1.1 Complete. SQLPlan generated by {planner_agent.name}. Plan: {sql_plan.model_dump_json(indent=2)}",
            # event="planner_agent_complete"
        )


if __name__ == "__main__":
    from agno.storage.sqlite import SqliteStorage
    from agno.utils.pprint import pprint_run_response

    storage_db_file = str(DATA_DIR / "orchestrator_main_session_storage.db")
    workflow_storage = SqliteStorage(
        table_name="orchestrator_sessions",
        db_file=storage_db_file,
        auto_upgrade_schema=True,
    )

    test_session_id = f"phase1_1_planner_test_{os.urandom(4).hex()}"
    # test_session_id = "fixed_planner_test_session" # Uncomment for repeatable session

    log.info(
        f"--- Starting Workflow for Phase 1.1: Planner_Agent Test (Session: {test_session_id}) ---"
    )

    orchestrator = Pipeline(
        name="MainOrchestrator_Phase1_1",
        session_id=test_session_id,
        storage=workflow_storage,
        debug_mode=True,
    )

    # The run method for Phase 1.1 now returns a single RunResponse or None
    final_response: RunResponse | None = orchestrator.run()

    if final_response:
        pprint_run_response(final_response, markdown=False)
        if final_response.content and "Error:" not in str(final_response.content):
            log.info(
                f"Successfully generated SQLPlan. Check logs and session state in '{storage_db_file}'."
            )
            # Can also pretty print the plan from the session state
            # stored_plan_dict = orchestrator.session_state.get('sql_plan_for_identity')
            # if stored_plan_dict:
            #    log.info(f"SQLPlan from session_state:\n{json.dumps(stored_plan_dict, indent=2)}")
        else:
            log.error(
                "Workflow run for Phase 1.1 encountered an error or did not produce SQLPlan."
            )
    else:
        log.error("Workflow run for Phase 1.1 did not return a response.")

    log.info("Phase 1.1 Test complete.")
